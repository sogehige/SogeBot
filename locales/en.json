{
  "core": {
    "loaded": "is loaded and",
    "enabled": "enabled",
    "disabled": "disabled",
    "usage": "Usage",
    "online": "Stream is online for (time)",
    "offline": "Stream is currently offline!",
    "lang-selected": "Bot language is currently set to english",
    "command-parse": "Sorry, (sender), but this command is not correct, use",
    "error": "Sorry, (sender), but something went wrong!",
    "mute": {
      "false": "Mute disabled. Bot will send messages."
    },
    "settings": {
      "uptime-format": "Uptime format set to (value)"
    }
  },
  "raffle": {
    "announceInterval": "Opened raffles will be announced every (value) minute",
    "commons": {
      "opened": "is opened! Use !(keyword) to join raffle!"
    },
    "info": {
      "opened": "(sender) Raffle {raffle.commons.opened}",
      "closed": "(sender) Raffle is closed, but winner is not picked yet!",
      "notRunning": "(sender) No raffle is currently opened!"
    },
    "open": {
      "error": "(sender) Raffle was not opened! Use: !raffle open [raffle-keyword] [followers(optional)]",
      "ok": "New raffle {raffle.commons.opened}",
      "notice": "Raffle {raffle.commons.opened}"
    },
    "close": {
      "ok": "Current raffle was closed! You cannot participate anymore!",
      "notRunning": "(sender) No raffle is currently running!"
    },
    "pick": {
      "winner": "Congratulations @(winner), you just won a raffle!",
      "noParticipants": "There were no participants in this raffle! No winner selected."
    }
  },
  "bets": {
      "newBet": "(sender), your current bet is (amount) (pointsName) on (option). You can win (winAmount) (winPointsName)!",
      "running": "(sender), bet is already opened! Use !bet close [(options)]",
      "notRunning": "No bet is currently opened, ask mods to open it!",
      "opened": "New bet is opened! Use !bet [(options)] [points] to win! You have only (minutes)min to bet!",
      "notEnoughOptions": "(sender), new bets needs at least 2 options!",
      "info": "Bets are opened! Use !bet [(options)] [points] to win! (time)min left to bet!",
      "parseError": "{core.command-parse} !bet to check usage",
      "diffBet": "(sender), you already made a bet on (option) and you cannot bet to different option!",
      "notEnoughPoints": "Sorry, (sender), but you dont have (amount) (pointsName) to bet!",
      "undefinedBet": "Sorry, (sender), but this bet option doesn't exist, use !bet to check usage",
      "betPercentGain": "Bet percent gain per option was set to (value)%",
      "betCloseTimer": "Bets will be automatically closed after (value)min",
      "refund": "Bets were closed without a winning. All users are refunded!",
      "notOption": "(sender), this option doesn't exist! Bet is not closed, check !bet",
      "closed": "Bets was closed and winning option was (option)! (amount) users won!",
      "timeUpBet": "I guess you are too late, (sender), your time for betting is up!",
      "locked": "Betting time is up! No more bets.",
      "zeroBet": "Oh boy, (sender), you cannot bet 0 (pointsName)",
      "lockedInfo": "Bets are opened, but time for betting is up!",
      "removed": "Betting time is up! No bets were sent -> automatically closing"
  },
  "alias": {
    "success": {
      "add": "Alias was added to database",
      "remove": "Alias was deleted from database",
      "list": "List of aliases"
    },
    "failed": {
      "add": "This alias already exists in database",
      "remove": "This alias cannot be found in database",
      "list": "List of aliases is empty",
      "parse": "{core.command-parse} !alias"
    }
  },
  "customcmds": {
    "success": {
      "add": "Command was added to database",
      "remove": "Command was deleted from database",
      "list": "List of commands"
    },
    "failed": {
      "add": "This command already exists in database",
      "remove": "This command cannot be found in database",
      "list": "List of commands is empty",
      "parse": "{core.command-parse} !command"
    }
  },
  "keywords": {
    "success": {
      "add": "Keyword was added to database",
      "remove": "Keyword was deleted from database",
      "list": "List of keywords"
    },
    "failed": {
      "add": "This keyword already exists in database",
      "remove": "This keyword cannot be found in database",
      "list": "List of keywords is empty",
      "parse": "{core.command-parse} !keyword"
    }
  },
  "notice": {
    "success": {
      "add": "Notice was added to database",
      "remove": "Notice was deleted from database",
      "list": "List of notices"
    },
    "failed": {
      "add": "This notice already exists in database",
      "notFound": "This notice cannot be found in database",
      "list": "List of notices is empty",
      "parse": "{core.command-parse} !notice"
    },
    "settings": {
      "noticeInterval": "Notice minimal interval succesfully set to (value) minutes",
      "noticeMsgReq": "Notice minimal required message chat count set to (value)"
    }
  },
  "points": {
    "success": {
      "set": "(username) was set to (amount) (pointsName)",
      "give": "(sender) just gave his (amount) (pointsName) to (username)",
      "all": "All online users just received (amount) (pointsName)!",
      "rain": "Make it rain! All online users just received up to (amount) (pointsName)!",
      "add": "(username) just received (amount) (pointsName)!",
      "remove": "Ouch, (amount) (pointsName) was removed from (username)!"
    },
    "failed": {
      "set": "{core.command-parse} !points set [username] [amount]",
      "give": "{core.command-parse} !points give [username] [amount]",
      "giveNotEnough": "Sorry, (sender), you don't have (amount) (pointsName) to give it to (username)",
      "get": "{core.command-parse} !points get [username]",
      "all": "{core.command-parse} !points all [amount]",
      "rain": "{core.command-parse} !makeitrain [amount]",
      "add": "{core.command-parse} !points add [username] [amount]",
      "remove": "{core.command-parse} !points remove [username] [amount]"
    },
    "settings": {
      "pointsName": "Points name was set to (value) format",
      "pointsResponse": "Points response was changed to: (value)",
      "pointsInterval": "Points online interval set to (value) minutes",
      "pointsPerInterval": "Points when online was set to (value) per online interval",
      "pointsIntervalOffline": "Points offline interval set to (value) minutes",
      "pointsPerIntervalOffline": "Points when offline was set to (value) per offline interval"
    },
    "defaults": {
      "pointsName": {
        "single": "point",
        "multi": "points",
        "xmulti": ""
      },
      "pointsResponse": "(username) has currently (amount) (pointsName)"
    }
  },
  "songs": {
    "settings": {
      "songrequest": {
        "text": "Song requests are ",
        "true": "{songs.settings.songrequest.text} {core.enabled}",
        "false": "{songs.settings.songrequest.text} {core.disabled}"
      },
      "playlist": {
        "text": "Playlist is ",
        "true": "{songs.settings.playlist.text} {core.enabled}",
        "false": "{songs.settings.playlist.text} {core.disabled}"
      },
      "volume": "Volume succesfully set to (value)%",
      "duration": "Maximum song length set to (value) minutes.",
      "shuffle": {
        "true": "Songs will play randomly",
        "false": "Songs will play by time added in playlist"
      }
    },
    "bannedSong": "Song (title) was banned and will never play again!",
    "bannedSongTimeout": "You've got timeout for posting banned song",
    "unbannedSong": "Song was succesfully unbanned",
    "notBannedSong": "This song was not banned",
    "currentSong": "Current song is (title)",
    "noCurrentSong": "No song is currently playing",
    "isBanned": "Sorry, (sender), but this song is banned",
    "notFound": "Sorry, (sender), but this song was not found",
    "tooLong": "Sorry, (sender), but this song is too long",
    "addedSong": "(title) was added to queue by (sender)",
    "addedSongPlaylist": "(title) was added to playlist",
    "removeSongQueue": "(title) was removed from queue",
    "alreadyInPlaylist": "Song (title) is already in playlist",
    "removeSongPlaylist": "(title) was removed from playlist"
  },
  "price": {
    "success": {
      "set": "Price for !(command) was set to (amount) (pointsName)",
      "remove" : "Price for !(command) was unset",
      "list": "List of prices"
    },
    "failed": {
      "parse": "{core.command-parse} !price",
      "remove": "No price was set for !(command)",
      "list": "List of prices is empty",
      "notEnough": "Sorry, (sender), but you don't have (amount) (pointsName) to use !(command)"
    }
  },
  "rank": {
    "success": {
      "add": "New rank was added to bot",
      "remove" : "Rank was deleted from bot",
      "list": "List of ranks",
      "show": "(sender) have (rank) rank"
    },
    "failed": {
      "parse": "{core.command-parse} !rank help",
      "add": "Rank for this hour already exists",
      "list": "List of ranks is empty",
      "notFound": "No rank is associated with this hour"
    }
  },
  "lastseen": {
    "success": {
      "never": "(username) was never in this channel!",
      "time": "(username) was last seen at (when) in this channel"
    },
    "failed": {
      "parse": "{core.command-parse} !lastseen [username]"
    }
  },
  "watched": {
    "success": {
      "time": "(username) watched this channel for (time) hours"
    },
    "failed": {
      "parse": "{core.command-parse} !watched or !watched [username]"
    }
  },
  "top": {
    "listWatched": "Top (amount) by watch time:",
    "listPoints": "Top (amount) by points:"
  },
  "permissions": {
    "success": {
      "change": "Permission for command was succesfully changed"
    },
    "failed": {
      "parse": "Usage: !permission viewer|mods|owner [command]",
      "noCmd": "Sorry, (sender), but this command is not registered in a bot"
    }
  },
  "moderation": {
    "warning": "[(value) warnings left]",
    "permit": "User (who) can post a link to chat",
    "links": "No links allowed, ask for !permit",
    "symbols": "No excessive symbols usage",
    "longMessage": "Long messages are not allowed",
    "caps": "No excessive caps usage",
    "spam": "Spamming is not allowed",
    "color": "Colors and /me is not allowed",
    "emotes": "No emotes spamming!",
    "failed": {
      "parsePermit": "{core.command-parse} !permit [username]"
    },
    "warnings": {
      "links": "{moderation.links} {moderation.warning}",
      "symbols": "{moderation.symbols} {moderation.warning}",
      "longMessage": "{moderation.longMessage} {moderation.warning}",
      "caps": "{moderation.caps} {moderation.warning}",
      "spam": "{moderation.spam} {moderation.warning}",
      "color": "{moderation.color} {moderation.warning}",
      "emotes": "{moderation.emotes} {moderation.warning}"
    },
    "settings": {
      "moderationLinks": {
        "text": "Moderation of links is",
        "true": "{moderation.settings.moderationLinks.text} {core.enabled}",
        "false": "{moderation.settings.moderationLinks.text} {core.disabled}"
      },
      "moderationLinksTimeout": "Timeout because of links set to (value)s",
      "moderationSymbols": {
        "text": "Moderation of symbols is",
        "true": "{moderation.settings.moderationSymbols.text} {core.enabled}",
        "false": "{moderation.settings.moderationSymbols.text} {core.disabled}"
      },
      "moderationSymbolsTimeout": "Timeout because of symbols set to (value)s",
      "moderationSymbolsTriggerLength": "Trigger message length for symbols set to (value)",
      "moderationSymbolsMaxConsecutively": "Maximum of consecutively written symbols set to (value)",
      "moderationSymbolsMaxPercent": "Maximum symbols percentage in message set to (value)%",
      "moderationLongMessage": {
        "text": "Moderation of long messages is",
        "true": "{moderation.settings.moderationLongMessage.text} {core.enabled}",
        "false": "{moderation.settings.moderationLongMessage.text} {core.disabled}"
      },
      "moderationLongMessageTimeout": "Timeout because of long message set to (value)s",
      "moderationLongMessageTriggerLength": "Trigger message length for long messages set to (value)",
      "moderationCaps": {
        "text": "Moderation of caps is",
        "true": "{moderation.settings.moderationCaps.text} {core.enabled}",
        "false": "{moderation.settings.moderationCaps.text} {core.disabled}"
      },
      "moderationCapsTimeout": "Timeout because of caps set to (value)s",
      "moderationCapsTriggerLength": "Trigger message length for caps set to (value)",
      "moderationCapsMaxPercent": "Maximum caps percentage in message set to (value)%",
      "moderationSpam": {
        "text": "Moderation of spam is",
        "true": "{moderation.settings.moderationSpam.text} {core.enabled}",
        "false": "{moderation.settings.moderationSpam.text} {core.disabled}"
      },
      "moderationSpamTimeout": "Timeout because of spam set to (value)s",
      "moderationSpamTriggerLength": "Trigger message length for spam set to (value)",
      "moderationSpamMaxLength": "Maximum spam length in message set to (value)",
      "moderationColor": {
        "text": "Moderation of colors (/me) is",
        "true": "{moderation.settings.moderationColor.text} {core.enabled}",
        "false": "{moderation.settings.moderationColor.text} {core.disabled}"
      },
      "moderationColorTimeout": "Timeout because of colors (/me) usage set to (value)s",
      "moderationEmotes": {
        "text": "Moderation of emotes is",
        "true": "{moderation.settings.moderationEmotes.text} {core.enabled}",
        "false": "{moderation.settings.moderationEmotes.text} {core.disabled}"
      },
      "moderationEmotesTimeout": "Timeout because of emotes spamming set to (value)s",
      "moderationEmotesMaxCount": "Maximum count of emotes in one messages set to (value)",
      "moderationWarnings": "User will be warned (value) times",
      "moderationWarningsTimeouts": {
        "true": "Warnings are set to be 1s timeout",
        "false": "Warnings are set to chat message only"
      }
    }
  },
  "queue": {
    "info": {
      "closed": "(sender), {queue.close}",
      "opened": "(sender), {queue.open}"
    },
    "join": {
      "closed": "Sorry (sender), queue is currently closed",
      "opened": "(sender) were added into queue"
    },
    "open": "Queue is currently OPENED! Join to queue with !queue join",
    "close": "Queue is currently closed!",
    "clear": "Queue were completely cleared",
    "picked": {
      "single": "This user was picked from queue: (users)",
      "multi": "These users were picked from queue: (users)",
      "none": "No users were found in queue"
    }
  },
  "title": {
    "current": "(sender), title of stream is '(title)'.",
    "change": {
      "success": "(sender), title was set to: (status)",
      "failed": "(sender), something went wrong. Current title is still set to: (status)"
    }
  },
  "game": {
    "current": "(sender), streamer is currently playing (game).",
    "change": {
      "success": "(sender), game was set to: (game)",
      "failed": "(sender), something went wrong. Current game is still set to: (game)"
    }
  },
  "cooldown": {
    "failed": {
      "parse": "{core.command-parse} !cooldown [command] [global|user] [seconds]",
      "cooldown": "(sender), you cannot use !(command), remaining (seconds)s"
    },
    "success": {
      "set": "(type) cooldown for !(command) was set to (seconds)s",
      "unset": "Cooldown for !(command) was unset"
    }
  }
}